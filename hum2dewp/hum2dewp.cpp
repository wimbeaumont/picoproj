
/*
 * Project for getting the dewpoint out as voltage 
 * Humidity / temperature sensor is HTM2500LF
 * the output voltage is generated by the PWM 
 * 
 * 
 * History :
 * V 0.5  read the humidity and temperature 
 * V 0.6  added the voltage output function 
 *        humidity readout is low in respect to other probes.
 *        checked voltages seems to be ok. 
 * V 0.7  activated the temperature dependency for the humidity readout 
 *        corrected bug in the dP to voltage output function ( PWM class) 
 * V 0.8  average humidiy 
 * V 0.9  introduce ADC read class to unify histograming ( avaraging) added float optimalization for pico 
 * 		   not tested   class is tested. 
 * V 0.91  use "float.h" #include "pico/types.h" #include "pico/bootrom/sf_table.h" not tested 
 * V 0.92  not tested with hardware.   Preps for ADC read class, the functions ADC2xx for ADC input 
 * V 0.93   uses the ADC class to read  
 * V 0.95  to many changes go back to 9.2 
 * V 0.96  added extra PWM in core 2  for testing the output circuit 
 * V 1.00  functional with hardware 
 * V 1.01  remove multiplying with 1000 and 0.0375 => 37.5
 * V 1.03  adjusted calibration values for humidity input
 * V 1.10  memic current output for humitidy 4mA -> 0.3636  , 20mA 1.181 V 
 * V 1.11  correction for setting 4mA ref 
 * 
 */
#define HUM2DEWPVER "1.11" 


#include <stdio.h>
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "hardware/adc.h"  
#include "hardware/watchdog.h"
#include "PWM_PICO.h" 
#include "math.h"
#include "float.h" 
#include "pico/types.h"
#include "pico/bootrom/sf_table.h"
#include "hum2dewputils.h"
enum ADCINP {HUMIN=0, TEMPIN=1 , VSYSIN=2 };
const unsigned int RDBUFSIZE=512;

void  serial_bufferflush(void) {stdio_flush();}

/* this is a kind of polling  reading with time out 
 * it loops max 5000 times checking the input buffer (waiting for 100us) 
 * if a char is found it checks for \n  , if this is the case it break the while loop and returns the number of char in the  readbuf 
 * else the char is placed in the readbuf
 * \r is ignored  
 * length of the readbuffer should be RDBUFSIZE ( to be defined) 
*/

int  read_noneblocking(  char* readbuf) {
	//for the moment still blocking , to be done  time out check 
	char recchar='$'; // just dummy 
	int bufcnt=0,cnt=0;readbuf[0]='\0';
	while (recchar != '\n') { // continue reading
		
		//kickWD();// as long in the reading routine don't init a WD restart 
		cnt++;
		int reccharpico=getchar_timeout_us(100);
		if ( reccharpico  != PICO_ERROR_TIMEOUT){
			recchar=(char) reccharpico;// char is read 
			cnt=0; //kickWD(); //printf("recchar %c \r\n",recchar);
			if ( recchar == '\r' ) continue; // ignore line feed 
			if ( recchar == '\n' ) {						
				readbuf[bufcnt]='\0';
				//printf("\n detected read done %s bufcnt = %d \n\r", readbuf,bufcnt);
			}		
			else {
				if ( bufcnt == RDBUFSIZE-1) { readbuf[0]='\0';recchar='\n' ;}
				else { readbuf[bufcnt]=recchar;
						//printf("%c , bufcnt %d  %c\r\n" , recchar, bufcnt,readbuf[bufcnt]);
						bufcnt++;
				}
			}
				
			}// end check if char is present
			if (cnt > 5000 ) {// stop reading 
				bufcnt=0; recchar='\n' ;
				serial_bufferflush();
			}
	} // end while check for \n 
			
	return bufcnt;
}	



	
// returns the voltage on the adcch 
float read_adc_ch( int adcch) {
	
	adc_select_input(adcch); 
	sleep_ms(50);
	return (float)adc_read() * VrefADC/(1<<12);
}


class read_adc_CH {
	int ch;
	float* hist;
	float sumh;
	float hs; // histogram size 
	int ringcnt;
	float avg;
	float (*radc)(int);
	public :
		//constructor,  if histsize >1 a histogram (array)  of histsize is created
		// adcch , the ADC channel
		// readadcf  , pointer to the function to read the ADC channel 
		read_adc_CH(int adcch ,float (*readadcf)(int), int histsize=0) {
			radc=readadcf;
			ch=adcch;
			float Nadc=read_adc_ch(ch);
			hs=histsize; hist=NULL; ringcnt=0;sumh=0.0;
			if (hs > 1 && hs < 100 ) hist=new float[(uint32_t)hs];
		}//end constructor 
		~read_adc_CH() {  if (hist) delete hist; } 
		// reads the ADC ch and returns the value 
		float get_cur_adc_V(void) {
			return read_adc_ch(ch);
		}
		//reads the ADC ch  and adds this value to the sum of the histogram removes the oldest value 
		//returns the average of the histogram.  
		float get_adcV(void) {
			if (hist) {
				int oldcnt=ringcnt+1;
				if (oldcnt >=  hs) oldcnt=0;
				sumh=sumh-hist[oldcnt];
				ringcnt++;
				if ( ringcnt >= hs )  ringcnt=0;
				hist[ringcnt]=radc(ch);
				sumh=sumh+hist[ringcnt];
				avg = sumh/hs;
			}
			else { avg=read_adc_ch(ch);}
			return avg;
		}
};





void core1_entry() {
	char readbuf[RDBUFSIZE];
	PWM_PICO pwmled( PICO_DEFAULT_LED_PIN);  //GPIO 25 
	pwmled.set_frequency(10000,true);
	float delta_l=.05 ;
	float dc_set ;
	while(1) {
		for (float dc =0; dc<100; dc+=delta_l) {
			if( delta_l < 2.5)delta_l=1.05*delta_l; // increase the delta each time
			dc_set=pwmled.set_dutycycle(dc);
			sleep_ms(200);
		}
		if ( read_noneblocking( readbuf)){
			printf( readbuf);
		}
		
		
		
	}
}


int main(){	

    stdio_init_all();
    // Enable the watchdog, requiring the watchdog to be updated every 5100ms or the chip will reboot
    // second arg is pause on debug which means the watchdog will pause when stepping through code
    watchdog_enable(5100, 1);
     PWM_PICO  outT(10,10000); // have to check for  optimal frequency 
     PWM_PICO  outDP(11,10000);
	// The ADC init part 
	float Hum; // humidity 
	float Tp; //temperature 
	float Vsys;// 5V power , ref for temperature 
	float dp; //dewpoint 
    adc_init();
    //read_adc_CH  Hadc(HUMIN,&read_adc_ch,16);
    //read_adc_CH  Tadc(TEMPIN,&read_adc_ch,16);
    //gpio_disable_pulls (26);  //Vsys 
    //gpio_disable_pulls (27);  // V
    //gpio_disable_pulls (28);
    adc_gpio_init(26);
    adc_gpio_init(27);
    adc_gpio_init(28);
    //just for fun
    multicore_launch_core1(core1_entry);
	for (uint i = 0; i < 25; i++) {
		printf("init %d\n", i);
		watchdog_update();
	}    

    if (watchdog_caused_reboot()) {
        printf("Rebooted by Watchdog ");
    } 
    printf("hum2dwp ver %s\n\r",HUM2DEWPVER);
    float  Rntc_now;
    outT.init_PWMVout(-40,50,0,3.3);
    //outDP.init_PWMVout(-60,20,0,3.3);out between 0 and 3.3 V 
    outDP.init_PWMVout(-60,20,0.3636,1.818); // for 20mA output equivalent 
    uint lc=0;
    while(1) {
			watchdog_update();
			Vsys=adc2Vsys(read_adc_ch(VSYSIN) );
			Tp= adc2Tp(read_adc_ch(TEMPIN), Rntc_now);
			Hum=adc2Hum(read_adc_ch(HUMIN ),Tp);
			dp=dewpoint(Hum,Tp);
			lc++;
			if( lc%100 == 0){
				printf("Vsys= %f ", Vsys );
				printf("H= %f ",Hum) ;
				printf("dp= %f ",dp);
				printf("T= %f ",Tp );
				printf("dT=%f ", outT.set_PWMVout(Tp));
				printf("dDP=%f", outDP.set_PWMVout(dp));
				printf("\n\r");
			}
	}

    return 0;
}
